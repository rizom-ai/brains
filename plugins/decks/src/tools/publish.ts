import type {
  PluginTool,
  ToolResponse,
  ServicePluginContext,
} from "@brains/plugins";
import { parseMarkdownWithFrontmatter } from "@brains/plugins";
import { z, formatAsEntity } from "@brains/utils";
import type { DeckEntity } from "../schemas/deck";
import { DeckFormatter } from "../formatters/deck-formatter";

/**
 * Input schema for deck:publish tool
 */
export const publishInputSchema = z.object({
  id: z.string().optional().describe("Deck ID"),
  slug: z.string().optional().describe("Deck slug"),
});

export type PublishInput = z.infer<typeof publishInputSchema>;

// Frontmatter schema for deck markdown files
const deckFrontmatterSchema = z.object({
  title: z.string(),
  slug: z.string().optional(),
  description: z.string().optional(),
  author: z.string().optional(),
  status: z.enum(["draft", "published"]).default("draft"),
  publishedAt: z.string().datetime().optional(),
  event: z.string().optional(),
});

/**
 * Create the deck:publish tool
 */
export function createPublishTool(
  context: ServicePluginContext,
  pluginId: string,
): PluginTool {
  const formatter = new DeckFormatter();

  return {
    name: `${pluginId}_publish`,
    description: "Publish a deck (sets publishedAt and triggers site rebuild)",
    inputSchema: publishInputSchema.shape,
    visibility: "anchor",
    handler: async (input: unknown): Promise<ToolResponse> => {
      try {
        const { id, slug } = publishInputSchema.parse(input);

        // Validate that at least one identifier is provided
        if (!id && !slug) {
          return {
            success: false,
            error: "Either 'id' or 'slug' must be provided",
            formatted: "_Error: Either 'id' or 'slug' must be provided_",
          };
        }

        // Get deck entity by ID or slug
        let deck: DeckEntity | null = null;

        if (id) {
          // Try to get by ID first
          deck = await context.entityService.getEntity<DeckEntity>("deck", id);
        } else if (slug) {
          // Search by slug in metadata
          const decks = await context.entityService.listEntities<DeckEntity>(
            "deck",
            {
              filter: { metadata: { slug } },
              limit: 1,
            },
          );
          deck = decks[0] ?? null;
        }

        if (!deck?.content) {
          const identifier = id ?? slug;
          return {
            success: false,
            error: `Deck not found: ${identifier}`,
            formatted: `_Deck not found: ${identifier}_`,
          };
        }

        // Parse frontmatter from content
        const parsed = parseMarkdownWithFrontmatter(
          deck.content,
          deckFrontmatterSchema,
        );

        // Update frontmatter with published status and timestamp
        const publishedAt = new Date().toISOString();
        const updatedFrontmatter = {
          ...parsed.metadata,
          status: "published" as const,
          publishedAt,
        };

        // Regenerate content with updated frontmatter using formatter
        const updatedDeck: DeckEntity = {
          ...deck,
          status: "published",
          publishedAt,
          metadata: {
            ...deck.metadata,
            status: "published",
            publishedAt,
          },
        };

        // Use formatter to generate markdown with frontmatter
        const updatedContent = formatter.toMarkdown(updatedDeck);

        // Update entity with new content
        const finalDeck: DeckEntity = {
          ...updatedDeck,
          content: parsed.content, // Keep only body content (frontmatter is regenerated by formatter)
        };

        const result = await context.entityService.updateEntity({
          ...finalDeck,
          content: updatedContent,
        });

        // Entity update will automatically trigger entity:updated message
        // which site-builder subscribes to for rebuilding

        const formatted = formatAsEntity(
          {
            id: deck.id,
            title: updatedFrontmatter.title,
            slug: deck.metadata.slug,
            status: "published",
            publishedAt,
          },
          { title: "Deck Published" },
        );

        return {
          success: true,
          data: { ...result, deck: finalDeck },
          message: `Deck "${updatedFrontmatter.title}" published successfully`,
          formatted,
        };
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        return {
          success: false,
          error: msg,
          formatted: `_Error: ${msg}_`,
        };
      }
    },
  };
}
