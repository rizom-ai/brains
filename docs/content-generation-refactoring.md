# Content Generation Architecture Refactoring

## Overview

This document outlines a proposed refactoring to separate content generation concerns from content persistence in the Personal Brain architecture. The current implementation mixes these concerns, leading to unnecessary complexity and the need for content "promotion" workflows.

## Current Architecture

### Problems with Current Design

1. **Mixed Concerns**: The `generated-content` entity type conflates two orthogonal concepts:
   - The structure and schema of content (e.g., landing pages, hero sections)
   - The fact that content was generated by AI

2. **Unnecessary Intermediate State**: Generated content must be "promoted" to become real content, even though the structure is identical.

3. **Duplicate Schema Handling**: Both `GeneratedContentAdapter` and target entity adapters handle the same content schemas.

4. **Complex Workflow**: Users must explicitly promote content instead of directly editing AI-generated drafts.

### Current Flow

```
User Request → AI Generation → generated-content entity → Promotion → site-content entity
```

## Proposed Architecture

### Core Principle: Separation of Concerns

1. **Structured Content Layer**
   - Defines schemas for all content types (landing pages, sections, etc.)
   - Provides formatters and validators
   - Agnostic to content origin (AI or manual)

2. **Content Generation Layer**
   - Pure AI/LLM service
   - Accepts prompts and returns structured data
   - No persistence responsibilities

3. **Persistence Layer**
   - Stores any content as appropriate entity type
   - Tracks metadata (including generation info)
   - No special handling for AI-generated content

### Proposed Flow

```
User Request → AI Generation → Structured Data → Direct save as target entity type
```

## Benefits

1. **Cleaner Architecture**: Each layer has a single, clear responsibility
2. **Simpler User Experience**: No promotion step needed
3. **Reusable Components**: Schemas and formatters used consistently
4. **Flexibility**: Easy to add new content types or generation strategies

## Implementation Plan

### Phase 1: Create Structured Content Package

Create `@brains/structured-content` package containing:
- Content schemas (landing pages, sections, etc.)
- Content formatters
- Validation utilities
- Type definitions for structured content

### Phase 2: Refactor Content Generation

Update `ContentGenerationService` to:
- Remove entity persistence logic
- Return structured data instead of saving entities
- Use schemas from structured-content package
- Focus purely on AI generation

### Phase 3: Update Entity Adapters

- Remove `generated-content` entity type
- Update site-content and other adapters to use structured-content package
- Add metadata fields for tracking content origin

### Phase 4: Update Plugins

- Modify plugins to save generated content directly
- Remove promotion tools
- Add editing capabilities for all content

## Migration Strategy

1. **Backward Compatibility**: Keep generated-content entity type temporarily
2. **Gradual Migration**: Update one plugin at a time
3. **Data Migration**: Script to convert existing generated-content entities

## Open Questions

### Content Promotion Workflow

While the refactoring eliminates the technical need for promotion, there may still be valid use cases:

1. **Draft vs Published**: Users may want to generate content as drafts before publishing
2. **Review Workflow**: Generated content might need approval before going live
3. **A/B Testing**: Keep multiple versions of content for comparison

**Possible Solutions:**
- Use entity metadata to track draft/published status
- Implement a separate review/approval system
- Version control for content entities

### Content Provenance

How do we track whether content was AI-generated or manually created?

**Options:**
1. Entity metadata field: `generatedBy: "ai" | "manual"`
2. Audit log of all changes
3. Separate draft entities that track origin

### Editing AI-Generated Content

Once content is saved, how do we handle:
- Regenerating specific sections
- Mixing manual edits with AI suggestions
- Maintaining content consistency

## Next Steps

1. Gather feedback on this proposal
2. Decide on promotion/workflow requirements
3. Create structured-content package
4. Begin phased implementation

## Example: New Architecture in Action

### Before (Current)
```typescript
// Generate content
const generated = await contentGenService.generate({
  prompt: "Create landing page",
  contentType: "landing-page",
  save: true  // Saves as generated-content entity
});

// Promote to real content
const promoted = await entityService.deriveEntity(
  generated.id,
  "generated-content", 
  "site-content"
);
```

### After (Proposed)
```typescript
// Generate content  
const data = await contentGenService.generate({
  prompt: "Create landing page",
  schema: landingPageSchema
});

// Save directly as target type
const entity = await entityService.createEntity({
  entityType: "site-content",
  page: "landing",
  data: data,
  metadata: {
    generatedBy: "ai",
    generatedAt: new Date()
  }
});
```

## Conclusion

This refactoring separates the concerns of content structure from content generation, resulting in a cleaner, more maintainable architecture. While we need to address workflow questions around promotion and editing, the technical benefits are clear.