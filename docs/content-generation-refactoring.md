# Content Generation Architecture Refactoring

## Overview

This document outlines a proposed refactoring to separate content generation concerns from content persistence in the Personal Brain architecture. The current implementation mixes these concerns, leading to unnecessary complexity and the need for content "promotion" workflows.

## Current Architecture

### Problems with Current Design

1. **Mixed Concerns**: The `generated-content` entity type conflates two orthogonal concepts:
   - The structure and schema of content (e.g., landing pages, hero sections)
   - The fact that content was generated by AI

2. **Unnecessary Intermediate State**: Generated content must be "promoted" to become real content, even though the structure is identical.

3. **Duplicate Schema Handling**: Both `GeneratedContentAdapter` and target entity adapters handle the same content schemas.

4. **Complex Workflow**: Users must explicitly promote content instead of directly editing AI-generated drafts.

### Current Flow

```
User Request → AI Generation → generated-content entity → Promotion → site-content entity
```

## Proposed Architecture

### Core Principle: Separation of Concerns

1. **Structured Content Layer**
   - Defines schemas for all content types (landing pages, sections, etc.)
   - Provides formatters and validators
   - Agnostic to content origin (AI or manual)

2. **Content Generation Layer**
   - Pure AI/LLM service
   - Accepts prompts and returns structured data
   - No persistence responsibilities

3. **Persistence Layer**
   - Stores any content as appropriate entity type
   - Tracks metadata (including generation info)
   - No special handling for AI-generated content

### Proposed Flow

```
User Request → AI Generation → Structured Data → Direct save as target entity type
```

## Benefits

1. **Cleaner Architecture**: Each layer has a single, clear responsibility
2. **Simpler User Experience**: No promotion step needed
3. **Reusable Components**: Schemas and formatters used consistently
4. **Flexibility**: Easy to add new content types or generation strategies

## Implementation Plan

### Phase 1: Create Structured Content Package

Create `@brains/structured-content` package containing:

- Content schemas (landing pages, sections, etc.)
- Content formatters
- Validation utilities
- Type definitions for structured content

### Phase 2: Refactor Content Generation

Update `ContentGenerationService` to:

- Remove entity persistence logic
- Return structured data instead of saving entities
- Use schemas from structured-content package
- Focus purely on AI generation

### Phase 3: Update Entity Adapters

- Remove `generated-content` entity type
- Update site-content and other adapters to use structured-content package
- Add metadata fields for tracking content origin

### Phase 3.5: Simplify Landing Page Architecture

During implementation, we discovered that the landing page reference pattern adds unnecessary complexity:

**Issue Identified:**

- Landing page stored as reference data (with heroId, featuresId, ctaId)
- Validation expects full data (with hero, features, cta objects)
- This mismatch causes constant regeneration of content

**Clarification - Astro Requirements:**

- Astro's static site generator needs a complete landing page YAML file
- The YAML must contain all sections (hero, features, cta) assembled together
- Individual section files won't work for the current Astro template

**Solution:**
Remove the landing page reference entity while maintaining YAML generation:

1. **Store only individual sections as entities**
   - Hero, features, and CTA sections exist as independent site-content entities
   - No separate landing page "index" entity in the database
   - Each section uses its own formatter for proper content structure

2. **YAML generation remains unchanged**
   - ContentGenerator still assembles the full landing page data
   - Writes complete landing/index.yaml for Astro
   - This YAML file is generated from the individual section entities

3. **Simplify content checking**
   - Check for existing hero, features, and cta sections individually
   - If all sections exist, skip generation
   - If any section is missing, regenerate all sections for consistency
   - No validation against landingPageSchema for existing content

4. **Benefits**
   - No duplication of data (sections are the single source of truth)
   - No complex reference resolution
   - Sections remain independent and editable
   - Astro still gets the complete YAML file it needs
   - Clear separation: database stores sections, YAML file is for Astro

5. **Implementation Changes**
   - Remove `landingPageReferenceSchema` and related types
   - Remove `LandingPageFormatter`
   - Remove code that creates landing:index entity
   - Update `generateLandingPage` to check for sections individually
   - Keep YAML assembly and writing logic unchanged

### Phase 4: Content Structure Reorganization

Reorganize content-related files into a hierarchical page/section structure:

1. **Create Folder Structure**
   - Move from flat file organization to nested page/section folders
   - Each content type gets its own folder with schema, formatter, and prompt
   - Example: `content/landing/hero/` contains schema.ts, formatter.ts, prompt.txt, and index.ts
   - The index.ts exports the complete template configuration
   - Composite schemas (like landing page) are also defined in the registry
   - Example: `content/landing/index/` contains the composite landing page schema

2. **Implement Content Registry**
   - Create a registry for dynamic content loading
   - Support content lookup by "page:section" pattern
   - Provide unified interface for accessing schemas, formatters, and templates

3. **Dynamic Schema Generation for Astro**
   - Replace content-schemas.txt workaround with runtime schema generation
   - Use zod-to-json-schema to convert runtime Zod schemas to JSON Schema
   - Use json-schema-to-zod to generate TypeScript code from JSON Schema
   - Generate complete content/config.ts file for Astro with all schemas inline
   - Maintain Zod as single source of truth - no hardcoded schema strings
   - Composite schemas (e.g., landingPageSchema) are defined once in the content registry
   - Generator is completely generic - just converts all registered schemas

4. **Update Dependencies**
   - ContentGenerator imports only the registry
   - WebserverPlugin uses registry for content type registration
   - Remove precompile script and manual schema copying
   - Reduce coupling between components

5. **Handling Composite Schemas**
   - Astro requires composite schemas for pages with multiple sections
   - Example: landing page needs title, tagline, plus all section data
   - Define composite schemas as regular templates in the registry
   - `content/landing/index/` contains landingPageSchema that combines sections
   - ContentGenerator validates against composite schema before writing YAML
   - No special cases in schema generator - treats all schemas equally

6. **Benefits**
   - Better organization and discoverability
   - Easier to add new content types
   - No more schema duplication or manual synchronization
   - Composite schemas are explicit and versioned
   - Supports future features like versioning and environments
   - Cleaner imports and reduced file sizes

### Phase 5: Environment-Based Content Management

Implement preview/production environment separation for content workflow:

1. **Environment Separation**
   - Add environment field to site-content entities ("preview" | "production")
   - Update ContentGenerator to write to specific environment
   - Modify queries to filter by environment

2. **Promotion Workflow**
   - Create promotion tool in webserver plugin
   - Copy content from preview to production environment
   - Track promotion metadata (promoted by, promoted at)
   - Support bulk promotion of related content

3. **Rollback Capability**
   - Keep version history when promoting
   - Add rollback tool to revert to previous versions
   - Track promotion history in metadata

### Phase 6: Collection-Based Content Architecture

Implement a collection-based content model to eliminate hardcoded template imports and enable generic content generation:

1. **Collection Model**

   Collections are content types that contain multiple related items, where each item is itself a ContentTemplate. We use a single interface to keep the registry simple:

   ```typescript
   interface ContentTemplate<T> {
     schema: z.ZodType<T>;
     basePrompt?: string;
     formatter?: ContentFormatter<T>;
     // For collection content types (validated at registration)
     items?: {
       [itemKey: string]: ContentTemplate<any>;
     };
   }
   ```

2. **Generic Content Generation**

   Move content generation from plugins to shell:
   - Create ContentGenerationService in shell package
   - Service discovers collection structure from ContentTypeRegistry
   - Handles both simple templates and collections:
     ```typescript
     async generate(contentType: string) {
       const template = registry.get(contentType);
       if (template.items) {
         // Collection: generate each item
         for (const [key, itemTemplate] of Object.entries(template.items)) {
           const data = await generateWithTemplate(itemTemplate);
           // Save with collection/item metadata
         }
       } else {
         // Simple content generation
       }
     }
     ```
   - Manages environments and persistence generically
   - No knowledge of specific content types needed

3. **Plugin Simplification**

   Plugins only declare content structure:

   ```typescript
   // Define item templates
   const heroTemplate: ContentTemplate<HeroData> = {
     schema: heroSchema,
     formatter: heroFormatter,
     basePrompt: "Generate a hero section...",
   };

   const featuresTemplate: ContentTemplate<FeaturesData> = {
     schema: featuresSchema,
     formatter: featuresFormatter,
     basePrompt: "Generate features section...",
   };

   // Register collection with its items
   registry.register("webserver:landing", {
     schema: landingCollectionSchema,
     items: {
       hero: heroTemplate,
       features: featuresTemplate,
       cta: ctaTemplate,
     },
   });
   ```

4. **Benefits**
   - **No Hardcoded Imports**: Collections dynamically declare their structure
   - **Reusable Templates**: Items are full ContentTemplates with all capabilities
   - **Generic Operations**: Shell can generate any collection without specific knowledge
   - **Clean Separation**: Plugins declare content, shell handles generation
   - **Simple Registry**: Single interface keeps ContentTypeRegistry unchanged
   - **Extensible**: Easy to add new collections or items

5. **Implementation Details**
   - **Naming Convention**:
     - Items: `plugin:collection:item` (e.g., `webserver:landing:hero`)
     - Collections: `plugin:collection` (e.g., `webserver:landing`)
   - **Storage**: Items stored as individual entities with collection/item metadata
   - **Assembly**: Collections assembled from items when needed (e.g., for YAML)
   - **Validation**: Registry validates that collections have required `items` field

6. **Migration Path**
   - Phase 6a: Update ContentTemplate interface in @brains/types
   - Phase 6b: Create ContentGenerationService in shell
   - Phase 6c: Refactor webserver plugin to use collections
   - Phase 6d: Remove ContentGenerator from webserver
   - Phase 6e: Update tools to use shell's content generation

### Phase 7: Content Editing Features

Add comprehensive content editing capabilities:

1. **Direct Content Editing**
   - Add edit_content tool to modify existing site-content
   - Support partial updates (edit specific fields)
   - Preserve formatting with round-trip parser support

2. **AI-Assisted Editing**
   - Add regenerate_section tool for specific content pieces
   - Support "improve" prompts that enhance existing content
   - Mix manual edits with AI suggestions
   - Track edit history in metadata

3. **Content Validation**
   - Validate edited content against schemas
   - Ensure consistency across related sections
   - Preview changes before saving

### Phase 7: Clean Up and Documentation

Finalize the refactoring with cleanup and documentation:

1. **Code Cleanup**
   - Remove any deprecated code paths
   - Optimize performance where needed
   - Ensure consistent error handling

2. **Documentation Updates**
   - Update README files for affected packages
   - Create user guides for new workflows
   - Document API changes
   - Add architecture diagrams

3. **Testing Improvements**
   - Add integration tests for full workflows
   - Test environment promotion scenarios
   - Add performance benchmarks
   - Ensure backward compatibility where needed

4. **Migration Support**
   - Create migration scripts if needed
   - Document breaking changes
   - Provide upgrade guides

## Migration Strategy

1. **Backward Compatibility**: Keep generated-content entity type temporarily
2. **Gradual Migration**: Update one plugin at a time
3. **Data Migration**: Script to convert existing generated-content entities

## Open Questions

### Content Promotion Workflow ✓ SOLVED

While the refactoring eliminates the technical need for promotion, there may still be valid use cases:

1. **Draft vs Published**: Users may want to generate content as drafts before publishing
2. **Review Workflow**: Generated content might need approval before going live
3. **A/B Testing**: Keep multiple versions of content for comparison

**Solution: Environment-Based Promotion**

Use the existing preview/production server architecture to handle content promotion:

- **Preview Environment** (port 3000): Where content is generated, edited, and reviewed
- **Production Environment** (port 8080): Where approved content is published

This approach:

- Leverages existing webserver plugin infrastructure
- Provides a familiar workflow for web developers
- Allows natural staging and review processes
- Eliminates complex entity type transformations
- Enables easy rollback by keeping previous production versions

Implementation:

1. Generate content directly into the preview environment
2. Review and edit content while viewing it in the preview server
3. "Promote" by copying content from preview to production
4. Track promotion history for rollback capabilities

### Content Provenance

How do we track whether content was AI-generated or manually created?

**Options:**

1. Entity metadata field: `generatedBy: "ai" | "manual"`
2. Audit log of all changes
3. Separate draft entities that track origin

### Editing AI-Generated Content

Once content is saved, how do we handle:

- Regenerating specific sections
- Mixing manual edits with AI suggestions
- Maintaining content consistency

## Next Steps

1. ~~Gather feedback on this proposal~~ ✓
2. ~~Decide on promotion/workflow requirements~~ ✓ (Environment-based approach)
3. Create structured-content package
4. Implement environment-based content management
5. Begin phased implementation

## Example: New Architecture in Action

### Before (Current)

```typescript
// Generate content
const generated = await contentGenService.generate({
  prompt: "Create landing page",
  contentType: "landing-page",
  save: true, // Saves as generated-content entity
});

// Promote to real content
const promoted = await entityService.deriveEntity(
  generated.id,
  "generated-content",
  "site-content",
);
```

### After (Proposed)

```typescript
// Generate content
const data = await contentGenService.generate({
  prompt: "Create landing page",
  schema: landingPageSchema,
});

// Save directly as target type
const entity = await entityService.createEntity({
  entityType: "site-content",
  page: "landing",
  data: data,
  metadata: {
    generatedBy: "ai",
    generatedAt: new Date(),
  },
});
```

### After (Section-Based Content)

```typescript
// Generate individual sections
const heroData = await contentGenService.generate({
  prompt: "Create hero section",
  schema: heroSectionSchema,
});

await entityService.createEntity({
  entityType: "site-content",
  page: "landing",
  section: "hero",
  content: heroFormatter.format(heroData), // Formatted content is source of truth
});

// Astro assembles page from sections
const hero = await entityService.getEntity("site-content", {
  page: "landing",
  section: "hero",
});
const features = await entityService.getEntity("site-content", {
  page: "landing",
  section: "features",
});
const cta = await entityService.getEntity("site-content", {
  page: "landing",
  section: "cta",
});

// Round-trip parsing when needed
const heroData = heroFormatter.parse(hero.content);
```

## Example: Environment-Based Workflow

```typescript
// 1. Generate content into preview environment
const content = await contentGenService.generate({
  prompt: "Create landing page hero section",
  schema: heroSectionSchema,
});

await entityService.createEntity({
  entityType: "site-content",
  environment: "preview", // Goes to preview
  page: "landing",
  section: "hero",
  data: content,
  metadata: {
    generatedBy: "ai",
    generatedAt: new Date(),
  },
});

// 2. User reviews in preview server (http://localhost:3000)
// Makes edits if needed...

// 3. Promote to production when ready
await contentService.promoteToProduction({
  page: "landing",
  section: "hero",
});

// 4. Content is now live on production server (http://localhost:8080)
```

## Conclusion

This refactoring separates the concerns of content structure from content generation, resulting in a cleaner, more maintainable architecture. With the environment-based promotion approach, we maintain a simple yet powerful workflow that leverages existing infrastructure and follows web development best practices.
