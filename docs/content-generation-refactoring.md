# Content Generation Architecture Refactoring

## Overview

This document outlines a proposed refactoring to separate content generation concerns from content persistence in the Personal Brain architecture. The current implementation mixes these concerns, leading to unnecessary complexity and the need for content "promotion" workflows.

## Current Architecture

### Problems with Current Design

1. **Mixed Concerns**: The `generated-content` entity type conflates two orthogonal concepts:

   - The structure and schema of content (e.g., landing pages, hero sections)
   - The fact that content was generated by AI

2. **Unnecessary Intermediate State**: Generated content must be "promoted" to become real content, even though the structure is identical.

3. **Duplicate Schema Handling**: Both `GeneratedContentAdapter` and target entity adapters handle the same content schemas.

4. **Complex Workflow**: Users must explicitly promote content instead of directly editing AI-generated drafts.

### Current Flow

```
User Request → AI Generation → generated-content entity → Promotion → site-content entity
```

## Proposed Architecture

### Core Principle: Separation of Concerns

1. **Structured Content Layer**

   - Defines schemas for all content types (landing pages, sections, etc.)
   - Provides formatters and validators
   - Agnostic to content origin (AI or manual)

2. **Content Generation Layer**

   - Pure AI/LLM service
   - Accepts prompts and returns structured data
   - No persistence responsibilities

3. **Persistence Layer**
   - Stores any content as appropriate entity type
   - Tracks metadata (including generation info)
   - No special handling for AI-generated content

### Proposed Flow

```
User Request → AI Generation → Structured Data → Direct save as target entity type
```

## Benefits

1. **Cleaner Architecture**: Each layer has a single, clear responsibility
2. **Simpler User Experience**: No promotion step needed
3. **Reusable Components**: Schemas and formatters used consistently
4. **Flexibility**: Easy to add new content types or generation strategies

## Implementation Plan

### Phase 1: Create Structured Content Package

Create `@brains/structured-content` package containing:

- Content schemas (landing pages, sections, etc.)
- Content formatters
- Validation utilities
- Type definitions for structured content

### Phase 2: Refactor Content Generation

Update `ContentGenerationService` to:

- Remove entity persistence logic
- Return structured data instead of saving entities
- Use schemas from structured-content package
- Focus purely on AI generation

### Phase 3: Update Entity Adapters

- Remove `generated-content` entity type
- Update site-content and other adapters to use structured-content package
- Add metadata fields for tracking content origin

### Phase 4: Update Plugins

- Modify plugins to save generated content directly
- Remove promotion tools
- Add editing capabilities for all content

## Migration Strategy

1. **Backward Compatibility**: Keep generated-content entity type temporarily
2. **Gradual Migration**: Update one plugin at a time
3. **Data Migration**: Script to convert existing generated-content entities

## Open Questions

### Content Promotion Workflow ✓ SOLVED

While the refactoring eliminates the technical need for promotion, there may still be valid use cases:

1. **Draft vs Published**: Users may want to generate content as drafts before publishing
2. **Review Workflow**: Generated content might need approval before going live
3. **A/B Testing**: Keep multiple versions of content for comparison

**Solution: Environment-Based Promotion**

Use the existing preview/production server architecture to handle content promotion:

- **Preview Environment** (port 3000): Where content is generated, edited, and reviewed
- **Production Environment** (port 8080): Where approved content is published

This approach:

- Leverages existing webserver plugin infrastructure
- Provides a familiar workflow for web developers
- Allows natural staging and review processes
- Eliminates complex entity type transformations
- Enables easy rollback by keeping previous production versions

Implementation:

1. Generate content directly into the preview environment
2. Review and edit content while viewing it in the preview server
3. "Promote" by copying content from preview to production
4. Track promotion history for rollback capabilities

### Content Provenance

How do we track whether content was AI-generated or manually created?

**Options:**

1. Entity metadata field: `generatedBy: "ai" | "manual"`
2. Audit log of all changes
3. Separate draft entities that track origin

### Editing AI-Generated Content

Once content is saved, how do we handle:

- Regenerating specific sections
- Mixing manual edits with AI suggestions
- Maintaining content consistency

## Next Steps

1. ~~Gather feedback on this proposal~~ ✓
2. ~~Decide on promotion/workflow requirements~~ ✓ (Environment-based approach)
3. Create structured-content package
4. Implement environment-based content management
5. Begin phased implementation

## Example: New Architecture in Action

### Before (Current)

```typescript
// Generate content
const generated = await contentGenService.generate({
  prompt: "Create landing page",
  contentType: "landing-page",
  save: true, // Saves as generated-content entity
});

// Promote to real content
const promoted = await entityService.deriveEntity(
  generated.id,
  "generated-content",
  "site-content",
);
```

### After (Proposed)

```typescript
// Generate content
const data = await contentGenService.generate({
  prompt: "Create landing page",
  schema: landingPageSchema,
});

// Save directly as target type
const entity = await entityService.createEntity({
  entityType: "site-content",
  page: "landing",
  data: data,
  metadata: {
    generatedBy: "ai",
    generatedAt: new Date(),
  },
});
```

## Example: Environment-Based Workflow

```typescript
// 1. Generate content into preview environment
const content = await contentGenService.generate({
  prompt: "Create landing page hero section",
  schema: heroSectionSchema,
});

await entityService.createEntity({
  entityType: "site-content",
  environment: "preview", // Goes to preview
  page: "landing",
  section: "hero",
  data: content,
  metadata: {
    generatedBy: "ai",
    generatedAt: new Date(),
  },
});

// 2. User reviews in preview server (http://localhost:3000)
// Makes edits if needed...

// 3. Promote to production when ready
await contentService.promoteToProduction({
  page: "landing",
  section: "hero",
});

// 4. Content is now live on production server (http://localhost:8080)
```

## Conclusion

This refactoring separates the concerns of content structure from content generation, resulting in a cleaner, more maintainable architecture. With the environment-based promotion approach, we maintain a simple yet powerful workflow that leverages existing infrastructure and follows web development best practices.
